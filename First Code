import UIKit
import Speech

class SearchViewController: UIViewController, SFSpeechRecognizerDelegate {

    var searchTextField: UITextField!
    var voiceSearchButton: UIButton!
    var speechRecognizer = SFSpeechRecognizer(locale: Locale(identifier: "en-US"))!
    var recognitionRequest: SFSpeechAudioBufferRecognitionRequest?
    var recognitionTask: SFSpeechRecognitionTask?
    let audioEngine = AVAudioEngine()

    override func viewDidLoad() {
        super.viewDidLoad()

        setupSearchTextField()
        setupVoiceSearchButton()
    }

    func setupSearchTextField() {
        searchTextField = UITextField()
        searchTextField.placeholder = "Type your search..."
        searchTextField.borderStyle = .roundedRect
        view.addSubview(searchTextField)
        
        // Set constraints for searchTextField
        searchTextField.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            searchTextField.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),
            searchTextField.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -50),
            searchTextField.centerYAnchor.constraint(equalTo: view.centerYAnchor)
        ])
    }

    func setupVoiceSearchButton() {
        voiceSearchButton = UIButton(type: .system)
        voiceSearchButton.setTitle("ðŸŽ¤", for: .normal)
        
        // Closure for handling the voice search action
        voiceSearchButton.actionHandler = { [weak self] in
            self?.startVoiceSearch()
        }

        view.addSubview(voiceSearchButton)

        // Set constraints for voiceSearchButton
        voiceSearchButton.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            voiceSearchButton.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20),
            voiceSearchButton.centerYAnchor.constraint(equalTo: searchTextField.centerYAnchor)
        ])
    }

    func startVoiceSearch() {
        if audioEngine.isRunning {
            audioEngine.stop()
            recognitionRequest?.endAudio()
        } else {
            startListening()
        }
    }

    func startListening() {
        // Ensure previous recognition tasks are canceled
        recognitionTask?.cancel()
        recognitionTask = nil

        // Configure audio session
        let audioSession = AVAudioSession.sharedInstance()
        try? audioSession.setCategory(.record, mode: .measurement, options: .duckOthers)
        try? audioSession.setActive(true, options: .notifyOthersOnDeactivation)

        recognitionRequest = SFSpeechAudioBufferRecognitionRequest()

        guard let inputNode = audioEngine.inputNode else {
            fatalError("Audio engine has no input node")
        }

        guard let recognitionRequest = recognitionRequest else {
            fatalError("Unable to create recognition request")
        }

        recognitionRequest.shouldReportPartialResults = true

        recognitionTask = speechRecognizer.recognitionTask(with: recognitionRequest) { [weak self] result, error in
            if let result = result {
                // Update the text field with recognized speech
                self?.searchTextField.text = result.bestTranscription.formattedString
            }

            if let error = error {
                print("Recognition error: \(error.localizedDescription)")
                self?.audioEngine.stop()
                inputNode.removeTap(onBus: 0)
            }
        }

        // Setup audio input
        let recordingFormat = inputNode.outputFormat(forBus: 0)
        inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) { (buffer, when) in
            self.recognitionRequest?.append(buffer)
        }

        audioEngine.prepare()
        try? audioEngine.start()
    }
}

extension UIButton {
    private struct AssociatedKeys {
        static var ActionHandler = "actionHandler"
    }

    var actionHandler: (() -> Void)? {
        get {
            return objc_getAssociatedObject(self, &AssociatedKeys.ActionHandler) as? (() -> Void)
        }
        set {
            objc_setAssociatedObject(self, &AssociatedKeys.ActionHandler, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
            addTarget(self, action: #selector(handleAction), for: .touchUpInside)
        }
    }

    @objc private func handleAction() {
        actionHandler?()
    }
}

